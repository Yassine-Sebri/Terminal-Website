{"ast":null,"code":"import main from\"./img/Smain.png\";import check from\"./img/Scheck.png\";import solved from\"./img/Ssolved.png\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";var MCS=function MCS(){return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"h1\",{children:\"Microcorruption: Sydney\"}),\"2021-03-01\",/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"br\",{}),\"As usual, let's start by taking a look at the \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"main\"}),\" \",\"function.\",/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"img\",{src:main,alt:\"main\"}),/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"br\",{}),\"Unlike last time, there doesn't seem to be a\",\" \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"create_password\"}),\" function, but the flow is pretty similar. First it gets a password from the user then it executes the\",\" \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"check_password\"}),\" function, and depending on the value of \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"r15\"}),\" after the execution it decides whether to open the lock or not. It seems that the\",\" \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"check_password\"}),\" function is key in this whole thing, so let's check it out.\",/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"img\",{src:check,alt:\"check_password\"}),/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"br\",{}),\"The \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"check_password\"}),\" performs a series of comparisons between the values stored at an offset from memory address\",\" \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"r15\"}),\" and a set of hexadecimal values. If the values match then \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"r15\"}),\" would receive the value 1, fulfilling the condition for unlocking the door. The memory values stored at \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"r15\"}),\" represent the password entered by the user, so all we have to do to solve the challenge is submit the hexadecimal values found in this function.\",/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"br\",{}),\"Submitting the values as is won't solve the challenge, however. This challenge was probably designed to teach people about the concepts of \\\"big endian\\\" and \\\"little endian\\\". A big endian system stores the most significant byte of a word at the smallest memory address while a little endian system does the opposite. This might seem a bit confusing but it just means that if you give a 16 bit CPU that uses little endian a value of \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"0x4142\"}),\", for example, it will be stored in memory as \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"0x4241\"}),\".\",/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"br\",{}),\"So in order to solve the challenge, we have to invert the hexadecimal values in the \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"check_password\"}),\" function two by two. So in this case the password would be (in hexadecimal)\",\" \",/*#__PURE__*/_jsx(\"span\",{id:\"code\",children:\"2e3c62496638332b\"}),/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"img\",{src:solved,alt:\"solved\"})]});};export default MCS;","map":{"version":3,"sources":["/home/kali/Development/Projects/terminal/src/components/Writeups/MCS.js"],"names":["main","check","solved","MCS"],"mappings":"AAAA,MAAOA,CAAAA,IAAP,KAAiB,iBAAjB,CACA,MAAOC,CAAAA,KAAP,KAAkB,kBAAlB,CACA,MAAOC,CAAAA,MAAP,KAAmB,mBAAnB,C,wFAEA,GAAMC,CAAAA,GAAG,CAAG,QAANA,CAAAA,GAAM,EAAM,CAChB,mBACE,oCACE,aADF,cAEE,+CAFF,2BAIE,aAJF,cAKE,aALF,+DAMgD,aAAM,EAAE,CAAC,MAAT,kBANhD,CAQU,GARV,0BAUE,aAVF,cAWE,aAXF,cAYE,YAAK,GAAG,CAAEH,IAAV,CAAgB,GAAG,CAAC,MAApB,EAZF,cAaE,aAbF,cAcE,aAdF,gDAe+C,GAf/C,cAgBE,aAAM,EAAE,CAAC,MAAT,6BAhBF,0GAiBuE,GAjBvE,cAkBE,aAAM,EAAE,CAAC,MAAT,4BAlBF,0DAmBK,aAAM,EAAE,CAAC,MAAT,iBAnBL,sFAoB0C,GApB1C,cAqBE,aAAM,EAAE,CAAC,MAAT,4BArBF,6EAuBE,aAvBF,cAwBE,aAxBF,cAyBE,YAAK,GAAG,CAAEC,KAAV,CAAiB,GAAG,CAAC,gBAArB,EAzBF,cA0BE,aA1BF,cA2BE,aA3BF,qBA4BM,aAAM,EAAE,CAAC,MAAT,4BA5BN,gGA6B6D,GA7B7D,cA8BE,aAAM,EAAE,CAAC,MAAT,iBA9BF,4EA+Ba,aAAM,EAAE,CAAC,MAAT,iBA/Bb,0HAiCK,aAAM,EAAE,CAAC,MAAT,iBAjCL,kKAoCE,aApCF,cAqCE,aArCF,mcA4CK,aAAM,EAAE,CAAC,MAAT,oBA5CL,+DA6CK,aAAM,EAAE,CAAC,MAAT,oBA7CL,kBA8CE,aA9CF,cA+CE,aA/CF,qGAiDgB,aAAM,EAAE,CAAC,MAAT,4BAjDhB,gFAkDyD,GAlDzD,cAmDE,aAAM,EAAE,CAAC,MAAT,8BAnDF,cAoDE,aApDF,cAqDE,aArDF,cAsDE,YAAK,GAAG,CAAEC,MAAV,CAAkB,GAAG,CAAC,QAAtB,EAtDF,GADF,CA0DD,CA3DD,CA6DA,cAAeC,CAAAA,GAAf","sourcesContent":["import main from \"./img/Smain.png\";\nimport check from \"./img/Scheck.png\";\nimport solved from \"./img/Ssolved.png\";\n\nconst MCS = () => {\n  return (\n    <div>\n      <br />\n      <h1>Microcorruption: Sydney</h1>\n      2021-03-01\n      <br />\n      <br />\n      As usual, let's start by taking a look at the <span id=\"code\">\n        main\n      </span>{\" \"}\n      function.\n      <br />\n      <br />\n      <img src={main} alt=\"main\" />\n      <br />\n      <br />\n      Unlike last time, there doesn't seem to be a{\" \"}\n      <span id=\"code\">create_password</span> function, but the flow is pretty\n      similar. First it gets a password from the user then it executes the{\" \"}\n      <span id=\"code\">check_password</span> function, and depending on the value\n      of <span id=\"code\">r15</span> after the execution it decides whether to\n      open the lock or not. It seems that the{\" \"}\n      <span id=\"code\">check_password</span> function is key in this whole thing,\n      so let's check it out.\n      <br />\n      <br />\n      <img src={check} alt=\"check_password\" />\n      <br />\n      <br />\n      The <span id=\"code\">check_password</span> performs a series of comparisons\n      between the values stored at an offset from memory address{\" \"}\n      <span id=\"code\">r15</span> and a set of hexadecimal values. If the values\n      match then <span id=\"code\">r15</span> would receive the value 1,\n      fulfilling the condition for unlocking the door. The memory values stored\n      at <span id=\"code\">r15</span> represent the password entered by the user,\n      so all we have to do to solve the challenge is submit the hexadecimal\n      values found in this function.\n      <br />\n      <br />\n      Submitting the values as is won't solve the challenge, however. This\n      challenge was probably designed to teach people about the concepts of \"big\n      endian\" and \"little endian\". A big endian system stores the most\n      significant byte of a word at the smallest memory address while a little\n      endian system does the opposite. This might seem a bit confusing but it\n      just means that if you give a 16 bit CPU that uses little endian a value\n      of <span id=\"code\">0x4142</span>, for example, it will be stored in memory\n      as <span id=\"code\">0x4241</span>.\n      <br />\n      <br />\n      So in order to solve the challenge, we have to invert the hexadecimal\n      values in the <span id=\"code\">check_password</span> function two by two.\n      So in this case the password would be (in hexadecimal){\" \"}\n      <span id=\"code\">2e3c62496638332b</span>\n      <br />\n      <br />\n      <img src={solved} alt=\"solved\" />\n    </div>\n  );\n};\n\nexport default MCS;\n"]},"metadata":{},"sourceType":"module"}